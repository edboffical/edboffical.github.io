<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>记录一次游戏服务 oom 抢救 - callous' blog</title><meta name=keywords content="tech"><meta name=description content="起因 原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！
先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，game 服务是用 c++ 写的。
解救玩家 因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致的 game 服务崩溃或者失去响应，导致玩家无法进入房间。玩家的 room 信息应该会存在缓存当中。大概看了下代码，定位到关键位置，这里贴一下部分代码：
这里不得不吐槽一下，既然 Enter 房间不成功都会 Remove 掉这个缓存，在房间不存在的时候竟然不做处理，直接返回。另外，更不能理解的是重启服务也不会删除这个缓存，也就是说 game 因为故障崩溃掉的话，这里的玩家永远都会提示 “房间不存在”。
现在知道了，玩家的 room 缓存在 memcache 里，只要清除掉这些失效的 key，就能解放这些玩家。但是问题又来了，仅凭 key 的 value 无法判断出这个玩家的 room 是否失效了。于是又去看代码，最后的解决方案是带这个 key 前缀的键值全部清除，虽然这样会对正常游戏的玩家有点小影响，但也是总结了诸多方案中影响最小的方案，也幸亏他不完全是依赖缓存去找玩家的房间。
平时工作中接触的大部分是 redis，对 memcache 相对了解较少。看了官方文档后，发现并没有批量删除的方法，也没有获取一个前缀所有 key 的类似命令，所以批量删除只能写脚本。
然后问题又来了，我们并不知道哪些玩家卡在房间里了，如果是全服遍历，明显不可能，因为有大概　1000w 的用户数据。
最后的方案，是从数据库查询导出了所有当天登陆过得用户，大概是 9w 多条，还能接受。
于是写了下面的 go 程序：
mc := memcache.New(&#34;memcache.xxxxxxx.xxxxx.xxxx.com:11211&#34;) fmt.Println(&#34;memcache error:&#34;, mc.Ping()) time.Sleep(time.Second * 2) dealCount := 0 for _, v := range config.Records { key := &#34;NOWSEVERID_&#34; + v."><meta name=author content="callous"><link rel=canonical href=https://callous.cn/blog/tech/oom/><link href=https://callous.cn/assets/css/stylesheet.min.595f5ecef354f9eb94e43d831cd360dcf8b7727542e731c55a7875c9e94a9577.css integrity="sha256-WV9ezvNU+euU5D2DHNNg3Pi3cnVC5zHFWnh1yelKlXc=" rel="preload stylesheet" as=style><link rel=manifest href=https://callous.cn/site.webmanifest><link rel=icon href=https://callous.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callous.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callous.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://callous.cn/apple-touch-icon.png><link rel=mask-icon href=https://callous.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><meta property="og:title" content="记录一次游戏服务 oom 抢救"><meta property="og:description" content="起因 原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！
先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，game 服务是用 c++ 写的。
解救玩家 因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致的 game 服务崩溃或者失去响应，导致玩家无法进入房间。玩家的 room 信息应该会存在缓存当中。大概看了下代码，定位到关键位置，这里贴一下部分代码：
这里不得不吐槽一下，既然 Enter 房间不成功都会 Remove 掉这个缓存，在房间不存在的时候竟然不做处理，直接返回。另外，更不能理解的是重启服务也不会删除这个缓存，也就是说 game 因为故障崩溃掉的话，这里的玩家永远都会提示 “房间不存在”。
现在知道了，玩家的 room 缓存在 memcache 里，只要清除掉这些失效的 key，就能解放这些玩家。但是问题又来了，仅凭 key 的 value 无法判断出这个玩家的 room 是否失效了。于是又去看代码，最后的解决方案是带这个 key 前缀的键值全部清除，虽然这样会对正常游戏的玩家有点小影响，但也是总结了诸多方案中影响最小的方案，也幸亏他不完全是依赖缓存去找玩家的房间。
平时工作中接触的大部分是 redis，对 memcache 相对了解较少。看了官方文档后，发现并没有批量删除的方法，也没有获取一个前缀所有 key 的类似命令，所以批量删除只能写脚本。
然后问题又来了，我们并不知道哪些玩家卡在房间里了，如果是全服遍历，明显不可能，因为有大概　1000w 的用户数据。
最后的方案，是从数据库查询导出了所有当天登陆过得用户，大概是 9w 多条，还能接受。
于是写了下面的 go 程序：
mc := memcache.New(&#34;memcache.xxxxxxx.xxxxx.xxxx.com:11211&#34;) fmt.Println(&#34;memcache error:&#34;, mc.Ping()) time.Sleep(time.Second * 2) dealCount := 0 for _, v := range config.Records { key := &#34;NOWSEVERID_&#34; + v."><meta property="og:type" content="article"><meta property="og:url" content="https://callous.cn/blog/tech/oom/"><meta property="article:published_time" content="2021-01-18T18:00:00+08:00"><meta property="article:modified_time" content="2021-01-18T18:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="记录一次游戏服务 oom 抢救"><meta name=twitter:description content="起因 原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！
先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，game 服务是用 c++ 写的。
解救玩家 因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致的 game 服务崩溃或者失去响应，导致玩家无法进入房间。玩家的 room 信息应该会存在缓存当中。大概看了下代码，定位到关键位置，这里贴一下部分代码：
这里不得不吐槽一下，既然 Enter 房间不成功都会 Remove 掉这个缓存，在房间不存在的时候竟然不做处理，直接返回。另外，更不能理解的是重启服务也不会删除这个缓存，也就是说 game 因为故障崩溃掉的话，这里的玩家永远都会提示 “房间不存在”。
现在知道了，玩家的 room 缓存在 memcache 里，只要清除掉这些失效的 key，就能解放这些玩家。但是问题又来了，仅凭 key 的 value 无法判断出这个玩家的 room 是否失效了。于是又去看代码，最后的解决方案是带这个 key 前缀的键值全部清除，虽然这样会对正常游戏的玩家有点小影响，但也是总结了诸多方案中影响最小的方案，也幸亏他不完全是依赖缓存去找玩家的房间。
平时工作中接触的大部分是 redis，对 memcache 相对了解较少。看了官方文档后，发现并没有批量删除的方法，也没有获取一个前缀所有 key 的类似命令，所以批量删除只能写脚本。
然后问题又来了，我们并不知道哪些玩家卡在房间里了，如果是全服遍历，明显不可能，因为有大概　1000w 的用户数据。
最后的方案，是从数据库查询导出了所有当天登陆过得用户，大概是 9w 多条，还能接受。
于是写了下面的 go 程序：
mc := memcache.New(&#34;memcache.xxxxxxx.xxxxx.xxxx.com:11211&#34;) fmt.Println(&#34;memcache error:&#34;, mc.Ping()) time.Sleep(time.Second * 2) dealCount := 0 for _, v := range config.Records { key := &#34;NOWSEVERID_&#34; + v."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"记录一次游戏服务 oom 抢救","name":"记录一次游戏服务 oom 抢救","description":"起因 原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！\n先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，game 服务是用 c++ 写的。\n解救玩家 因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致 …","keywords":["tech"],"articleBody":"起因 原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！\n先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，game 服务是用 c++ 写的。\n解救玩家 因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致的 game 服务崩溃或者失去响应，导致玩家无法进入房间。玩家的 room 信息应该会存在缓存当中。大概看了下代码，定位到关键位置，这里贴一下部分代码：\n这里不得不吐槽一下，既然 Enter 房间不成功都会 Remove 掉这个缓存，在房间不存在的时候竟然不做处理，直接返回。另外，更不能理解的是重启服务也不会删除这个缓存，也就是说 game 因为故障崩溃掉的话，这里的玩家永远都会提示 “房间不存在”。\n现在知道了，玩家的 room 缓存在 memcache 里，只要清除掉这些失效的 key，就能解放这些玩家。但是问题又来了，仅凭 key 的 value 无法判断出这个玩家的 room 是否失效了。于是又去看代码，最后的解决方案是带这个 key 前缀的键值全部清除，虽然这样会对正常游戏的玩家有点小影响，但也是总结了诸多方案中影响最小的方案，也幸亏他不完全是依赖缓存去找玩家的房间。\n平时工作中接触的大部分是 redis，对 memcache 相对了解较少。看了官方文档后，发现并没有批量删除的方法，也没有获取一个前缀所有 key 的类似命令，所以批量删除只能写脚本。\n然后问题又来了，我们并不知道哪些玩家卡在房间里了，如果是全服遍历，明显不可能，因为有大概　1000w 的用户数据。\n最后的方案，是从数据库查询导出了所有当天登陆过得用户，大概是 9w 多条，还能接受。\n于是写了下面的 go 程序：\nmc := memcache.New(\"memcache.xxxxxxx.xxxxx.xxxx.com:11211\") fmt.Println(\"memcache error:\", mc.Ping()) time.Sleep(time.Second * 2) dealCount := 0 for _, v := range config.Records { key := \"NOWSEVERID_\" + v.Mid err := mc.Delete(key) if err == nil { fmt.Println(key) } else { fmt.Println(err.Error(), key) } dealCount++ if dealCount == 200 { dealCount = 0 time.Sleep(time.Millisecond * 20) } } 为了尽量不影响业务，每次处理 200 条数据后，休息 20ms。最后生成二进制文件去服务器上跑了一下，大概 10 多秒跑完，成功解救数万玩家！\n定位原因 解救完玩家之后还有一个重要的工作，就是定位事故的原因。虽然从开始我就觉得像是进程 oom，但是查看了所有 game 进程，都是 2020 年启动的，并没有最近启动的 game 进程（ps：我竟然如此相信前同事写的服务崩了会重启！）\n但最后还是用命令 dmesg -T | egrep -i -C30 'killed process' 看了一下，如下图：\n真巧，就干掉了 friend3 这个服务，而我查看所有 game 进程的时候 0 1 2 进程都健在，让我误以为所有进程并没有 oom。（再一次吐槽，服务崩溃竟然没有重启机制…）\n最后问了客服部门的妹子，玩家开始反馈的时间正好是晚上九点左右，所以顺利破案，内存占用过高，导致 oom，致使 game 服务挂掉。\n最后来看一下，进程 oom 时候的内存情况。因为定位到原因的时候已经是第二天了，要查看前一天的内存使用情况，就要用到 linux 的 sar 工具，它是目前 linux 最为全面的性能分析工具，可以从多方面对系统活动进行报告，包括文件读写情况、系统调用的使用情况、磁盘I/O、cpu效率、内存使用情况等。\n用命令 sar -r -f /var/log/sa/sa17 查看发当天的内存使用信息（sa17表示这个月17号），找到事发时间点，如下：\n加上 buffers 和 cached 才 300 多 mb 可用内存，所以就干掉了那个进程。\n结语 到这里，这次擦屁股工作基本都完成了。总结一下，还是要健全内存监控机制，写代码不能完全依赖服务正常运行。最重要的一点！！多思多虑，谨防内存泄漏！\n","wordCount":"167","inLanguage":"en","datePublished":"2021-01-18T18:00:00+08:00","dateModified":"2021-01-18T18:00:00+08:00","author":{"@type":"Person","name":"callous"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://callous.cn/blog/tech/oom/"},"publisher":{"@type":"Organization","name":"callous' blog","logo":{"@type":"ImageObject","url":"https://callous.cn/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://callous.cn accesskey=h>callous' blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://callous.cn/archives/><span>Archives</span></a></li><li><a href=https://callous.cn/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>记录一次游戏服务 oom 抢救<div class=entry-isdraft><sup>&nbsp;&nbsp;[draft]</sup></div></h1><div class=post-meta>January 18, 2021&nbsp;·&nbsp;1 min&nbsp;·&nbsp;callous</div></header><div class=post-content><h2 id=起因>起因</h2><p>原本愉快的周日晚上，突然有客服部门的妹子在群里说游戏挂了！进不去了！还有一堆房间不存在的问题！</p><p>先说下这个挂掉的游戏，是从别的部门接手过来的，原班人马基本都离职了，留下一堆杂乱的资料，<em><strong>game</strong></em> 服务是用 <em><strong>c++</strong></em> 写的。</p><h2 id=解救玩家>解救玩家</h2><p>因为事情出得比较急，而且导致了大规模的玩家不能登录游戏，所以领导的首先要求是解救玩家。单从现象上分析，大致猜测是某些原因导致的 <em><strong>game</strong></em> 服务崩溃或者失去响应，导致玩家无法进入房间。玩家的 <em><strong>room</strong></em> 信息应该会存在缓存当中。大概看了下代码，定位到关键位置，这里贴一下部分代码：</p><p><img src=../../../tech/oom/room.png alt=图1></p><p>这里不得不吐槽一下，既然 <em><strong>Enter</strong></em> 房间不成功都会 <em><strong>Remove</strong></em> 掉这个缓存，在房间不存在的时候竟然不做处理，直接返回。另外，更不能理解的是重启服务也不会删除这个缓存，也就是说 <em><strong>game</strong></em> 因为故障崩溃掉的话，这里的玩家永远都会提示 <em><strong>“房间不存在”</strong></em>。</p><p>现在知道了，玩家的 <em><strong>room</strong></em> 缓存在 <em><strong>memcache</strong></em> 里，只要清除掉这些失效的 <em><strong>key</strong></em>，就能解放这些玩家。但是问题又来了，仅凭 <em><strong>key</strong></em> 的 <em><strong>value</strong></em> 无法判断出这个玩家的 <em><strong>room</strong></em> 是否失效了。于是又去看代码，最后的解决方案是带这个 <em><strong>key</strong></em> 前缀的键值全部清除，虽然这样会对正常游戏的玩家有点小影响，但也是总结了诸多方案中影响最小的方案，也幸亏他不完全是依赖缓存去找玩家的房间。</p><p>平时工作中接触的大部分是 <em><strong>redis</strong></em>，对 <em><strong>memcache</strong></em> 相对了解较少。看了官方文档后，发现并没有批量删除的方法，也没有获取一个前缀所有 <em><strong>key</strong></em> 的类似命令，所以批量删除只能写脚本。</p><p>然后问题又来了，我们并不知道哪些玩家卡在房间里了，如果是全服遍历，明显不可能，因为有大概　<em><strong>1000w</strong></em> 的用户数据。</p><p>最后的方案，是从数据库查询导出了所有当天登陆过得用户，大概是 <em><strong>9w</strong></em> 多条，还能接受。</p><p>于是写了下面的 <code>go</code> 程序：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>mc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>memcache</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;memcache.xxxxxxx.xxxxx.xxxx.com:11211&#34;</span>)

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;memcache error:&#34;</span>, <span style=color:#a6e22e>mc</span>.<span style=color:#a6e22e>Ping</span>())
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>)
	<span style=color:#a6e22e>dealCount</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Records</span> {
		<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;NOWSEVERID_&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Mid</span>
		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mc</span>.<span style=color:#a6e22e>Delete</span>(<span style=color:#a6e22e>key</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>key</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>(), <span style=color:#a6e22e>key</span>)
		}
		<span style=color:#a6e22e>dealCount</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dealCount</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>200</span> {
			<span style=color:#a6e22e>dealCount</span> = <span style=color:#ae81ff>0</span>
			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>20</span>)
		}
	}
</code></pre></div><p>为了尽量不影响业务，每次处理 <em><strong>200</strong></em> 条数据后，休息 <em><strong>20ms</strong></em>。最后生成二进制文件去服务器上跑了一下，大概 <em><strong>10</strong></em> 多秒跑完，成功解救数万玩家！</p><h2 id=定位原因>定位原因</h2><p>解救完玩家之后还有一个重要的工作，就是定位事故的原因。虽然从开始我就觉得像是进程 <em><strong>oom</strong></em>，但是查看了所有 <em><strong>game</strong></em> 进程，都是 <em><strong>2020</strong></em> 年启动的，并没有最近启动的 <em><strong>game</strong></em> 进程（ps：我竟然如此相信前同事写的服务崩了会重启！）</p><p>但最后还是用命令 <code>dmesg -T | egrep -i -C30 'killed process'</code> 看了一下，如下图：</p><p><img src=../../../tech/oom/oom1.png alt=图2></p><p>真巧，就干掉了 <em><strong>friend3</strong></em> 这个服务，而我查看所有 <em><strong>game</strong></em> 进程的时候 <em><strong>0 1 2</strong></em> 进程都健在，让我误以为所有进程并没有 oom。（再一次吐槽，服务崩溃竟然没有重启机制&mldr;）</p><p>最后问了客服部门的妹子，玩家开始反馈的时间正好是晚上九点左右，所以顺利破案，内存占用过高，导致 <em><strong>oom</strong></em>，致使 <em><strong>game</strong></em> 服务挂掉。</p><p>最后来看一下，进程 oom 时候的内存情况。因为定位到原因的时候已经是第二天了，要查看前一天的内存使用情况，就要用到 <em><strong>linux</strong></em> 的 <em><strong>sar</strong></em> 工具，它是目前 <em><strong>linux</strong></em> 最为全面的性能分析工具，可以从多方面对系统活动进行报告，包括文件读写情况、系统调用的使用情况、磁盘I/O、cpu效率、内存使用情况等。</p><p>用命令 <code>sar -r -f /var/log/sa/sa17</code> 查看发当天的内存使用信息（sa17表示这个月17号），找到事发时间点，如下：</p><p><img src=../../../tech/oom/oom2.png alt=图3></p><p>加上 <code>buffers</code> 和 <code>cached</code> 才 <em><strong>300</strong></em> 多 <em><strong>mb</strong></em> 可用内存，所以就干掉了那个进程。</p><h2 id=结语>结语</h2><p>到这里，这次擦屁股工作基本都完成了。总结一下，还是要健全内存监控机制，写代码不能完全依赖服务正常运行。最重要的一点！！多思多虑，谨防内存泄漏！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://callous.cn/tags/tech>tech</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://callous.cn>callous' blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://callous.cn/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${id}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>