<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>一次 lua 虚拟机堆栈溢出排查 - callous' blog</title><meta name=keywords content="tech"><meta name=description content="起因 这一次的问题出现在我开发的安全系统的 agent 中，在正式发布之前，测试到了这个问题，还算幸运😅 在内网测试环境中，agent 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了&mldr;
日志分析 {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:50:27.023&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:51:27.104&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:53:27.296&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?"><meta name=author content="callous"><link rel=canonical href=https://callous.cn/blog/tech/registry/><link href=https://callous.cn/assets/css/stylesheet.min.595f5ecef354f9eb94e43d831cd360dcf8b7727542e731c55a7875c9e94a9577.css integrity="sha256-WV9ezvNU+euU5D2DHNNg3Pi3cnVC5zHFWnh1yelKlXc=" rel="preload stylesheet" as=style><link rel=manifest href=https://callous.cn/site.webmanifest><link rel=icon href=https://callous.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callous.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callous.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://callous.cn/apple-touch-icon.png><link rel=mask-icon href=https://callous.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><meta property="og:title" content="一次 lua 虚拟机堆栈溢出排查"><meta property="og:description" content="起因 这一次的问题出现在我开发的安全系统的 agent 中，在正式发布之前，测试到了这个问题，还算幸运😅 在内网测试环境中，agent 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了&mldr;
日志分析 {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:50:27.023&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:51:27.104&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:53:27.296&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?"><meta property="og:type" content="article"><meta property="og:url" content="https://callous.cn/blog/tech/registry/"><meta property="article:published_time" content="2021-06-03T17:00:00+08:00"><meta property="article:modified_time" content="2021-06-03T17:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="一次 lua 虚拟机堆栈溢出排查"><meta name=twitter:description content="起因 这一次的问题出现在我开发的安全系统的 agent 中，在正式发布之前，测试到了这个问题，还算幸运😅 在内网测试环境中，agent 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了&mldr;
日志分析 {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:50:27.023&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:51:27.104&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&#34;,&#34;lua&#34;:&#34;port.lua&#34;} {&#34;level&#34;:&#34;error&#34;,&#34;ts&#34;:&#34;2021-05-31 19:53:27.296&#34;,&#34;caller&#34;:&#34;workers/luaworker.go:132&#34;,&#34;msg&#34;:&#34;call run func failed&#34;,&#34;error&#34;:&#34;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一次 lua 虚拟机堆栈溢出排查","name":"一次 lua 虚拟机堆栈溢出排查","description":"起因 这一次的问题出现在我开发的安全系统的 agent 中，在正式发布之前，测试到了这个问题，还算幸运😅 在内网测试环境中，agent 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了\u0026amp;hellip; …","keywords":["tech"],"articleBody":"起因 这一次的问题出现在我开发的安全系统的 agent 中，在正式发布之前，测试到了这个问题，还算幸运😅 在内网测试环境中，agent 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了…\n日志分析 {\"level\":\"error\",\"ts\":\"2021-05-31 19:50:27.023\",\"caller\":\"workers/luaworker.go:132\",\"msg\":\"call run func failed\",\"error\":\"/data/dep/agent/lua/utils.lua:38: registry overflow\\nstack traceback:\\n\\t[G]: in function 'gsub'\\n\\t/data/dep/agent/lua/utils.lua:38: in function 'split'\\n\\tlua/port.lua:42: in function 'inspect'\\n\\tlua/port.lua:21: in main chunk\\n\\t[G]: ?\",\"lua\":\"port.lua\"} {\"level\":\"error\",\"ts\":\"2021-05-31 19:51:27.104\",\"caller\":\"workers/luaworker.go:132\",\"msg\":\"call run func failed\",\"error\":\"/data/dep/agent/lua/utils.lua:38: registry overflow\\nstack traceback:\\n\\t[G]: in function 'gsub'\\n\\t/data/dep/agent/lua/utils.lua:38: in function 'split'\\n\\tlua/port.lua:42: in function 'inspect'\\n\\tlua/port.lua:21: in main chunk\\n\\t[G]: ?\",\"lua\":\"port.lua\"} {\"level\":\"error\",\"ts\":\"2021-05-31 19:53:27.296\",\"caller\":\"workers/luaworker.go:132\",\"msg\":\"call run func failed\",\"error\":\"/data/dep/agent/lua/utils.lua:38: registry overflow\\nstack traceback:\\n\\t[G]: in function 'gsub'\\n\\t/data/dep/agent/lua/utils.lua:38: in function 'split'\\n\\tlua/port.lua:42: in function 'inspect'\\n\\tlua/port.lua:21: in main chunk\\n\\t[G]: ?\",\"lua\":\"port.lua\"} 这里只截取了几条，可以看到，关键信息就是 registry overflow 。\n故障定位 项目中的 Lua 虚拟机是 GopherLua 是用 Go 语言编写的 Lua 5.1 的虚拟机和编译器。轻量化、性能高。\n先看一下这个 registry 是什么，在项目中的解释：\n  The registry of an LState implements stack storage for calling functions (both Lua and Go functions) and also for temporary variables in expressions. Its storage requirements will increase with callstack usage and also with code complexity.\n  就是调用函数（包括 lua 和 go）和临时变量的堆栈。\n底层源码阅读 来看下 registry 的底层结构\ntype registry struct { array []LValue top int growBy int maxSize int alloc *allocator handler registryHandler } 主要看 array 和 top，其中 array 用来保存栈值，top 是用来记录栈顶指针。\n然后，我们看一下什么情况下会触发堆栈溢出。\nfunc (rg *registry) Push(v LValue) { newSize := rg.top + 1 // this section is inlined by go-inline \t// source function is 'func (rg *registry) checkSize(requiredSize int) ' in '_state.go' \t{ requiredSize := newSize if requiredSize  cap(rg.array) { rg.resize(requiredSize) } } rg.array[rg.top] = v rg.top++ } 从 Push 操作中可以看到，每一次 Push 都会检查栈容量是否足够，如果不够就会触发 resize。\nfunc (rg *registry) resize(requiredSize int) { // +inline-start \tnewSize := requiredSize + rg.growBy // give some padding \tif newSize  rg.maxSize { newSize = rg.maxSize } if newSize requiredSize { rg.handler.registryOverflow() return } rg.forceResize(newSize) } // +inline-end 而在 resize 函数中，可以清楚的看到，当栈容量超过 maxSize （默认为 5120）的时候就会触发 registryOverflow 即堆栈溢出。\n至此，问题其实已经十分明确了。应该是某些操作压栈之后没有取出，导致堆栈一直堆积，最后导致溢出。\nDebug 在进行 Debug 的时候发现，在每一次虚拟机回收的时候，栈顶指针一直在递增：\n前一次回收： 后一次回收： 栈值都是 LNil： 按照时间推算，agent 的脚本一分钟执行一次，那么堆满一个容量 5120 的虚拟机堆栈，需要 1 天多，4 个虚拟机实例正好就是 5 天左右，完全符合故障现象。\n排查问题 接下来，最主要就是找到问题的原因，首先需要明确到底是 go 导致了堆栈堆积还是调用 lua 脚本的时候导致的。\n于是，我就写了一个十分简单的测试 lua 脚本，只 print 一条信息。\n然后，我发现虚拟机回收的时候堆栈依旧在堆积。说明问题大概率出在 go 里。\n所以我又仔细回顾了 agent 里虚拟机的执行流程，发现这处代码：\n// 调用 run 函数 if err := vm.CallByParam(lua.P{ Fn: rfn, NRet: 1, Protect: true, }, nil); err != nil { log.Logger.Error(\"call run func failed\", zap.Error(err), zap.Any(\"lua\", lname)) } // 归还虚拟机 luavm.Put(vm) 问题貌似就在这里，是不是调用 lua 脚本中的 run 函数后将结果压栈了，然后没有进行 POP ？\nagent 中调用的 lua 脚本是不返回值的，这也解释了为什么栈值都是 LNil。\n为了验证这个问题，我将测试脚本中的 run 方法改成了如下：\nfunction run() inspect() return 123 end 然后，我们再来 Debug 看下堆栈里的情况\n果然，类型从 LNil 变成了 LNumber，问题果然在这里！\n修复 // 调用 run 函数 if err := vm.CallByParam(lua.P{ Fn: rfn, NRet: 1, Protect: true, }, nil); err != nil { log.Logger.Error(\"call run func failed\", zap.Error(err), zap.Any(\"lua\", lname)) } // 相信我，调用 call 后一定要 pop ！！不然一定不会让你失望 vm.Pop(1) // 归还虚拟机 luavm.Put(vm) 修复这个问题很简单，只需在归还虚拟机前，执行一次 POP。随后发现每次回收虚拟机的时候，就没有栈堆积的情况了。\n另外，也可以在虚拟机回收的时候做一些资源清理。\n总结 多阅读底层实现，多去揪揪问题的本质，一般没有什么解决不了的问题😎\n","wordCount":"396","inLanguage":"en","datePublished":"2021-06-03T17:00:00+08:00","dateModified":"2021-06-03T17:00:00+08:00","author":{"@type":"Person","name":"callous"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://callous.cn/blog/tech/registry/"},"publisher":{"@type":"Organization","name":"callous' blog","logo":{"@type":"ImageObject","url":"https://callous.cn/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://callous.cn accesskey=h>callous' blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://callous.cn/archives/><span>Archives</span></a></li><li><a href=https://callous.cn/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>一次 lua 虚拟机堆栈溢出排查<div class=entry-isdraft><sup>&nbsp;&nbsp;[draft]</sup></div></h1><div class=post-meta>June 3, 2021&nbsp;·&nbsp;2 min&nbsp;·&nbsp;callous</div></header><div class=post-content><h2 id=起因>起因</h2><p>这一次的问题出现在我开发的安全系统的 <strong>agent</strong> 中，在正式发布之前，测试到了这个问题，还算幸运😅
在内网测试环境中，<strong>agent</strong> 一直都没出现问题，直到运行五六天后，突然发现 lua 虚拟机崩溃了&mldr;</p><h2 id=日志分析>日志分析</h2><pre><code>{&quot;level&quot;:&quot;error&quot;,&quot;ts&quot;:&quot;2021-05-31 19:50:27.023&quot;,&quot;caller&quot;:&quot;workers/luaworker.go:132&quot;,&quot;msg&quot;:&quot;call run func failed&quot;,&quot;error&quot;:&quot;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&quot;,&quot;lua&quot;:&quot;port.lua&quot;}
{&quot;level&quot;:&quot;error&quot;,&quot;ts&quot;:&quot;2021-05-31 19:51:27.104&quot;,&quot;caller&quot;:&quot;workers/luaworker.go:132&quot;,&quot;msg&quot;:&quot;call run func failed&quot;,&quot;error&quot;:&quot;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&quot;,&quot;lua&quot;:&quot;port.lua&quot;}
{&quot;level&quot;:&quot;error&quot;,&quot;ts&quot;:&quot;2021-05-31 19:53:27.296&quot;,&quot;caller&quot;:&quot;workers/luaworker.go:132&quot;,&quot;msg&quot;:&quot;call run func failed&quot;,&quot;error&quot;:&quot;/data/dep/agent/lua/utils.lua:38: registry overflow\nstack traceback:\n\t[G]: in function 'gsub'\n\t/data/dep/agent/lua/utils.lua:38: in function 'split'\n\tlua/port.lua:42: in function 'inspect'\n\tlua/port.lua:21: in main chunk\n\t[G]: ?&quot;,&quot;lua&quot;:&quot;port.lua&quot;}
</code></pre><p>这里只截取了几条，可以看到，关键信息就是 <strong>registry overflow</strong> 。</p><h2 id=故障定位>故障定位</h2><p>项目中的 <code>Lua</code> 虚拟机是 <a href=https://github.com/yuin/gopher-lua>GopherLua</a> 是用 Go 语言编写的 Lua 5.1 的虚拟机和编译器。轻量化、性能高。</p><p>先看一下这个 <code>registry</code> 是什么，在项目中的解释：</p><blockquote><blockquote><p>The registry of an LState implements stack storage for calling functions (both Lua and Go functions) and also for temporary variables in expressions. Its storage requirements will increase with callstack usage and also with code complexity.</p></blockquote></blockquote><p>就是调用函数（包括 lua 和 go）和临时变量的堆栈。</p><h3 id=底层源码阅读>底层源码阅读</h3><p>来看下 <a href=https://github.com/yuin/gopher-lua/blob/f4c35e4016d9d8580b007ebaeb68ecd8e0b09f1c/state.go#L369><code>registry</code></a> 的底层结构</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>registry</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>array</span>   []<span style=color:#a6e22e>LValue</span>
	<span style=color:#a6e22e>top</span>     <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>growBy</span>  <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>maxSize</span> <span style=color:#66d9ef>int</span>
	<span style=color:#a6e22e>alloc</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>allocator</span>
	<span style=color:#a6e22e>handler</span> <span style=color:#a6e22e>registryHandler</span>
}
</code></pre></div><p>主要看 <code>array</code> 和 <code>top</code>，其中 <code>array</code> 用来保存栈值，<code>top</code> 是用来记录栈顶指针。</p><p>然后，我们看一下什么情况下会触发堆栈溢出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>registry</span>) <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>LValue</span>) {
	<span style=color:#a6e22e>newSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>top</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
	<span style=color:#75715e>// this section is inlined by go-inline
</span><span style=color:#75715e></span>	<span style=color:#75715e>// source function is &#39;func (rg *registry) checkSize(requiredSize int) &#39; in &#39;_state.go&#39;
</span><span style=color:#75715e></span>	{
		<span style=color:#a6e22e>requiredSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newSize</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>requiredSize</span> &gt; cap(<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>array</span>) {
			<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>requiredSize</span>)
		}
	}
	<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>array</span>[<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>top</span>] = <span style=color:#a6e22e>v</span>
	<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>top</span><span style=color:#f92672>++</span>
}
</code></pre></div><p>从 <a href=https://github.com/yuin/gopher-lua/blob/f4c35e4016d9d8580b007ebaeb68ecd8e0b09f1c/state.go#L436><code>Push</code></a> 操作中可以看到，每一次 <code>Push</code> 都会检查栈容量是否足够，如果不够就会触发 <a href=https://github.com/yuin/gopher-lua/blob/f4c35e4016d9d8580b007ebaeb68ecd8e0b09f1c/state.go#L388><code>resize</code></a>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>registry</span>) <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>requiredSize</span> <span style=color:#66d9ef>int</span>) { <span style=color:#75715e>// +inline-start
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>newSize</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>requiredSize</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>growBy</span> <span style=color:#75715e>// give some padding
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newSize</span> &gt; <span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>maxSize</span> {
		<span style=color:#a6e22e>newSize</span> = <span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>maxSize</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newSize</span> &lt; <span style=color:#a6e22e>requiredSize</span> {
		<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>registryOverflow</span>()
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#a6e22e>rg</span>.<span style=color:#a6e22e>forceResize</span>(<span style=color:#a6e22e>newSize</span>)
} <span style=color:#75715e>// +inline-end
</span></code></pre></div><p>而在 <code>resize</code> 函数中，可以清楚的看到，当栈容量超过 <code>maxSize</code> （默认为 5120）的时候就会触发 <code>registryOverflow</code> 即堆栈溢出。</p><p>至此，问题其实已经十分明确了。应该是某些操作压栈之后没有取出，导致堆栈一直堆积，最后导致溢出。</p><h3 id=debug>Debug</h3><p>在进行 <code>Debug</code> 的时候发现，在每一次虚拟机回收的时候，栈顶指针一直在递增：</p><p>前一次回收：
<img src=../../../tech/registry/01.png alt=图1></p><p>后一次回收：
<img src=../../../tech/registry/02.png alt=图2></p><p>栈值都是 <code>LNil</code>：
<img src=../../../tech/registry/03.png alt=图3></p><p>按照时间推算，<strong>agent</strong> 的脚本一分钟执行一次，那么堆满一个容量 <code>5120</code> 的虚拟机堆栈，需要 <code>1</code> 天多，<code>4</code> 个虚拟机实例正好就是 <code>5</code> 天左右，完全符合故障现象。</p><h3 id=排查问题>排查问题</h3><p>接下来，最主要就是找到问题的原因，首先需要明确到底是 <code>go</code> 导致了堆栈堆积还是调用 <code>lua</code> 脚本的时候导致的。</p><p>于是，我就写了一个十分简单的测试 <code>lua</code> 脚本，只 <code>print</code> 一条信息。</p><p>然后，我发现虚拟机回收的时候堆栈依旧在堆积。说明问题大概率出在 <code>go</code> 里。</p><p>所以我又仔细回顾了 <strong>agent</strong> 里虚拟机的执行流程，发现这处代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 调用 run 函数
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>CallByParam</span>(<span style=color:#a6e22e>lua</span>.<span style=color:#a6e22e>P</span>{
	<span style=color:#a6e22e>Fn</span>:      <span style=color:#a6e22e>rfn</span>,
	<span style=color:#a6e22e>NRet</span>:    <span style=color:#ae81ff>1</span>,
	<span style=color:#a6e22e>Protect</span>: <span style=color:#66d9ef>true</span>,
}, <span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;call run func failed&#34;</span>, <span style=color:#a6e22e>zap</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>), <span style=color:#a6e22e>zap</span>.<span style=color:#a6e22e>Any</span>(<span style=color:#e6db74>&#34;lua&#34;</span>, <span style=color:#a6e22e>lname</span>))
}
<span style=color:#75715e>// 归还虚拟机
</span><span style=color:#75715e></span><span style=color:#a6e22e>luavm</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>vm</span>)
</code></pre></div><p>问题貌似就在这里，是不是调用 <code>lua</code> 脚本中的 <code>run</code> 函数后将结果压栈了，然后没有进行 <code>POP</code> ？</p><p><strong>agent</strong> 中调用的 <code>lua</code> 脚本是不返回值的，这也解释了为什么栈值都是 <code>LNil</code>。</p><p>为了验证这个问题，我将测试脚本中的 <code>run</code> 方法改成了如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>run</span>()
    inspect()
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>123</span>
<span style=color:#66d9ef>end</span>
</code></pre></div><p>然后，我们再来 <code>Debug</code> 看下堆栈里的情况</p><p><img src=../../../tech/registry/04.png alt=图4></p><p>果然，类型从 <code>LNil</code> 变成了 <code>LNumber</code>，问题果然在这里！</p><h3 id=修复>修复</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 调用 run 函数
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>CallByParam</span>(<span style=color:#a6e22e>lua</span>.<span style=color:#a6e22e>P</span>{
	<span style=color:#a6e22e>Fn</span>:      <span style=color:#a6e22e>rfn</span>,
	<span style=color:#a6e22e>NRet</span>:    <span style=color:#ae81ff>1</span>,
	<span style=color:#a6e22e>Protect</span>: <span style=color:#66d9ef>true</span>,
}, <span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Logger</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;call run func failed&#34;</span>, <span style=color:#a6e22e>zap</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>), <span style=color:#a6e22e>zap</span>.<span style=color:#a6e22e>Any</span>(<span style=color:#e6db74>&#34;lua&#34;</span>, <span style=color:#a6e22e>lname</span>))
}

<span style=color:#75715e>// 相信我，调用 call 后一定要 pop ！！不然一定不会让你失望
</span><span style=color:#75715e></span><span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>Pop</span>(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e>// 归还虚拟机
</span><span style=color:#75715e></span><span style=color:#a6e22e>luavm</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>vm</span>)
</code></pre></div><p>修复这个问题很简单，只需在归还虚拟机前，执行一次 POP。随后发现每次回收虚拟机的时候，就没有栈堆积的情况了。</p><p>另外，也可以在虚拟机回收的时候做一些资源清理。</p><h2 id=总结>总结</h2><p>多阅读底层实现，多去揪揪问题的本质，一般没有什么解决不了的问题😎</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://callous.cn/tags/tech>tech</a></li></ul></footer><figure class=article-discussion><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"edboffical"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></figure></article></main><footer class=footer><span>&copy; 2021 <a href=https://callous.cn>callous' blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://callous.cn/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${id}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>